## Chap4. CPU의 작동 원리

### 4-1 ALU와 제어장치

>**ALU**
<img width="377" alt="Screenshot 2023-07-12 at 9 51 45 PM" src="https://github.com/Guel-git/iOS-CS-Study/assets/81340603/433d01d7-afe5-45bc-9be3-74b42002efe2">

<br>

**ALU가 받아들이는 정보**
- 피연산자와 연산 내용이 필요함
- 레지스터를 통해 피연산자를, 제어장치로 연산 내용인 제어 신호를 받아들임

<br>
  
**ALU가 내보내는 정보**
- 결과는 일시적으로 레지스터에 저장됨
  - CPU가 메모리에 접근하는 데 걸리는 시간 >>> 레지스터에 접근하는 데 걸리는 시간 이므로,
  - 프로그램 실행 속도를 높이기 위해서
- 플래그는 플래그 레지스터에 저장됨
  - 플래그: 연산 결과에 대한 추가적인 정보
    
    <img width="481" alt="Screenshot 2023-07-12 at 10 02 10 PM" src="https://github.com/Guel-git/iOS-CS-Study/assets/81340603/8963c141-4345-4d2e-8e41-8a088e0454be">
- 이밖에도 ALU 내부에 존재하는 회로들
  - 가산기(+), 보수기(-), 시프터, 오버플로우 검출기 등

<br>

>**제어 장치**

<img width="484" alt="Screenshot 2023-07-12 at 10 16 53 PM" src="https://github.com/Guel-git/iOS-CS-Study/assets/81340603/bbf930bb-473e-4808-b6b6-ef938ff1c86c">

- 제어 장치: 제어 신호를 내보내고 명령어를 해석하는 부품
- 제어 신호: 컴퓨터 부품들을 관리하고 작동시키기 위한 일종의 전기 신호

<br>

**제어장치가 받아들이는 정보**
1. 클럭 신호
   - 클럭: 컴퓨터의 모든 부품을 움직이게 하는 시간 단위
   - 컴퓨터 부품들은 클럭이라는 박자에 맞춰 작동함 (한 박자마다 작동하는 건 아님)
2. 해석해야 할 명령어
   - 명령어 레지스터로부터 온 명령어
3. 플래그 레지스터 속 플래그 값
   - 플래그 값을 참고하여 제어 신호를 발생시킴
4. 제어 버스로 전달된 제어 신호

<br>

**제어장치가 내보내는 정보**
- CPU 외부에 전달하는 제어 신호 - 제어 버스로 제어 신호를 내보냄
  - 메모리에 전달하는 제어 신호
    - 메모리에 저장된 값을 읽거나 메모리에 새로운 값을 쓰고 싶을 때
  - 입출력 장치에 전달하는 제어 신호
    - 입출력 장치의 값을 읽거나 입출력 장치에 새로운 값을 쓰고 싶을 때
- CPU 내부에 전달하는 제어 신호
  - ALU에 전달하는 제어 신호
    - 수행할 연산 지시
  - 레지스터에 전달하는 제어 신호
    - 레지스터 간에 데이터 이동
    - 레지스터에 저장된 명령어 해석

### 4-2 레지스터
명령어와 데이터는 실행 전후로 반드시 레지스터에 저장됨 > 레지스터를 관찰하면 프로그램의 실행 흐름을 파악할 수 있음

**반드시 알아야 할 레지스터**
1. 프로그램 카운터: 메모리에서 다음으로 읽어 들일 명령어의 주소 저장
2. 명령어 레지스터: 방금 메모리에서 읽어 들인 명령어 저장
3. 메모리 주소 레지스터: 메모리 주소 저장
4. 메모리 버퍼 레지스터 (메모리 데이터 레지스터): 메모리에 쓰고 싶은 값이나 메모리부터 전달받은 값
5. 플래그 레지스터: 연산 결과 또는 CPU 상태에 대한 부가적인 정보 저장
6. 범용 레지스터: 다양하고 일반적인 상황에서 자유롭게 사용
7. 스택 포인터
8. 베이스 레지스터

<br>

**특정 레지스터를 이용한 주소 지정 방식 (1): 스택 주소 지정 방식**

<img width="484" alt="Screenshot 2023-07-12 at 10 38 30 PM" src="https://github.com/Guel-git/iOS-CS-Study/assets/81340603/2711ad09-f465-4223-a144-a20a7c75e1d3">

- 스택과 스택 포인터를 이용한 주소 지정 방식
- 스택 포인터: 스택의 꼭대기를 가리키는 레지스터
- 인터럽트 발생시 기존 CPU 진행 상황을 백업해두는 곳으로 메모리 안에 존재

<br>

**특정 레지스터를 이용한 주소 지정 방식 (2): 변위 주소 지정 방식**

<img width="480" alt="Screenshot 2023-07-12 at 10 39 52 PM" src="https://github.com/Guel-git/iOS-CS-Study/assets/81340603/1ebed58f-b100-4d56-aa9a-9024356e9add">

- 오퍼랜드 필드의 값과 특정 레지스터의 값을 더해 유효 주소를 얻어내는 주소 지정 방식
- 이 방식을 사용하는 명령어는 [연산 코드, 더할 레지스터 값, 주소를 담는 오퍼랜드 필드]

<br>

**상대 주소 지정 방식**

<img width="480" alt="Screenshot 2023-07-12 at 10 54 44 PM" src="https://github.com/Guel-git/iOS-CS-Study/assets/81340603/00ec4dfc-5aa4-4afe-8157-241d4089f300">

- 오퍼랜드 + 프로그램 카운터(읽어 들일 명령어의 주소) = 유효 주소를 얻는 방식
- 분기하여 특정 주소의 코드를 실행할 때 사용

<br>

**베이스 레지스터 주소 지정 방식**

<img width="389" alt="Screenshot 2023-07-12 at 10 59 47 PM" src="https://github.com/Guel-git/iOS-CS-Study/assets/81340603/08228674-9856-4cb8-a6f7-bb5353a30797">

- 어퍼랜드 + 베이스 레지스터 = 유효 주소를 얻는 방식

<br>

### 4-3 명령어 사이클과 인터럽트

>**명령어 사이클**

<img width="282" alt="Screenshot 2023-07-12 at 11 10 17 PM" src="https://github.com/Guel-git/iOS-CS-Study/assets/81340603/9470a34f-6a8c-4ae0-900c-0ff30f50688c">

- 하나의 명령어를 처리하는 정형화된 흐름 / 프로그램이 실행되며 반복되는 일정한 주기

1. 인출 사이클: 메모리에 있는 명령어를 CPU로 가져오는 단계
2. 실행 사이클: 제어 장치가 명령어 레지스터에 담긴 값을 해석하고, 제어 신호를 발생시키는 단계
3. 간접 사이클: 메모리 접근을 한 번 더 하는 단계
   - 명령어를 인출한 뒤에 바로 실행 사이클에 돌입할 수 없는 경우 ex. 간접 주소 지정 방식(유효 주소의 주소)

<br>

>**인터럽트**

명령어를 처리하다 흐름이 끊어지는 상황, CPU의 작업을 방해하는 신호

**동기 인터럽트**
- CPU에 의해 발생하는 인터럽트
- 예외적인 상황에 마주쳤을 때 발생 => 예외 exception

**비동기 인터럽트**
- 주로 입출력 장치에 의해 발생하는 인터럽트
- ex 프린터가 프린트를 끝낸 후 cPU에게 완료 인터럽트를 보냄
- 하드웨어 인터럽트
  - 명령어를 효율적으로 처리하기 위해 사용됨
  - 순서
    1. 입출력 장치는 CPU에 *인터럽트 요청 신호*를 보냄
    2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 인터럽트 여부를 확인함
    3. CPU는 인터럽트 요청을 확인하고 *인터럽트 플래그*를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인함
       - 인터럽트 플래그: 인터럽트를 받아들일지 결정하는 플래그 (in 플래그 레지스터)
       - 인터럽트 플래그가 불가능이어도 무시할 수 없는 인터럽트 존재 - 정전, 하드웨어 고장 등
    4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업함 (at 메모리 스택)
    5. CPU는 *인터럽트 벡터*를 참조하여 *인터럽트 서비스 루틴*을 실행함
       - 인터럽트 서비스 루틴 (인터럽트 핸들러): 인터럽트를 처리하기 위한 프로그램, 어떻게 행동해야 할지를 알려주는 프로그램
       - 인터럽트 벡터: 인터럽트 서비스 루틴을 식별하기 위한 정보 (주소 역할)
    6. 인터럽트 서비스 루틴이 끝나면 4에서 백업해 둔 작업 복구 후 실행 재개
