## Chap14. 가상 메모리

### 14-1 연속 메모리 할당

>**메모리 영역**
- 커널 영역: 운영체제가 상주하는 영역 (낮은 주소)
- 사용자 영역: 프로세스가 올라가는 영역 (높은 주소)

<br>

>**사용자 영역 메모리 할당 방식**
- Contiguous allocation (연속 메모리 할당): 프로세스가 메모리에 통째로 올라가는 방식
- Noncontiguous allocation (불연속 할당): 잘게 쪼개서 분산되어 올라가는 방식

<br>

>**Swapping**

<img>

메모리에서 사용되지 않는 일부 프로세스를 보조기억장치(backing store)로 내보내고 실행할 프로세스를 메모리로 들여보내는 메모리 관리 기법

메모리의 크기가 실행되고자 하는 프로세스들의 크기 합보다 작아도 스와핑을 통해 해당 프로세스들을 동시에 실행할 수 있게 됨

- swap space: 프로세스들이 쫒겨나는 보조기억장치의 일부 영역
- swap-out: 실행되지 않는 프로세스가 메모리 ➡️ 스왑 영역으로 옮겨지는 것
- swap-in: 스왑 영역에 있던 프로세스 ➡️ 메모리로 옮겨오는 것

<br> 

>**메모리 할당**

메모리 내에 있는 빈 공간들 중 어느 곳에 실행 될 프로세스를 할당할까?

- First fit (최초 적합): 탐색 중 가장 먼저 발견된 공간에 배치하는 방식
- Best fit (최적 적합): 빈 공간 중 프로세스가 적재될 수 있는 가장 작은 공간에 프로세스를 배치하는 방식
- Worst fit (최악 적합): 빈 공간 중 프로세스가 적재될 수 있는 가장 큰 공간에 프로세스를 배치

<br>

>**외부 단편화와 내부 단편화**

- External fragmentation (외부 단편화, 외부 조각): 프로세스를 할당하기 어려울 만큼 작은 메모리 공간(hole)들로 인해 메모리가 낭비되는 현상
- Interal fragmentation (내부 단편화, 내부 조각): 프로세스의 크기보다 분할된 메모리 공간이 큰 경우

- Compactation (압축): 흩어져 있는 빈 공간들을 하나로 모으는 방식, 시스템 일시중지 및 작업의 오버헤드가 큼 

<br>

### 14-2 페이징을 통한 가상 메모리 관리

>**가상 메모리**

- 연속 할당 방식의 문제
    - external fragmentation
    - 물리 메모리보다 큰 프로세스를 실행할 수 없음

- 실행하고자 하는 프로그램을 일부만 메모리에 적재하는 기술 
- 페이징과 세그멘테이션이 있음

<br>

>**페이징**

프로세스의 논리 주소 공간을 일정한 단위로 나눠 할당하는 가상 메모리 관리 기법

- Page: 논리 주소를 나누는 일정한  단위
- Frame: 물리 주소 공간을 나누는 일정한 단위
- 페이지와 프레임의 크기는 동일함

- Page in: 페이징 시스템에서의 스왑 인, 보조기억장치 ➡️ 메모리
- Page out: 페이징 시스템에서의 스왑 아웃, 메모리 ➡️ 보조기억장치

- 페이징은 외부 단편화 문제는 해결해주지만 내부 단편화 문제를 야기함

<br>

>**페이지 테이블**

<img>

물리 주소에 프로세스가 불연속적으로 할당되어도 논리 주소에는 연속적으로 배치되도록 페이지 번호와 프레임 번호를 짝지어 주는 이정표

- 메모리의 커널 영역에 저장됨
- PTBR (Page Table Base Register): 각 프로세스의 페이지 테이블이 적재된 주소를 가리킴, 프로세스가 실행될 때 바뀜
- TLB (Translation Lookaside Buffer): 페이지 테이블의 일부 정보를 저장한 캐시 메모리 
    - 페이지 테이블을 이용했을 때 메모리 접근이 2번 필요한 문제를 해결하기 위해 등장
    - 일반적으로 MMU에 저장됨
    - TLB 히트: 페이지 번호가 TLB에 있을 경우
    - TLB 미스: 페이지 번호가 TLB에 없을 경우

<br>

>**페이징에서의 주소 변환**

<img>

- Page number: 접근하고자 하는 페이지 번호
- Offset: 프레임 시작 번지로부터 떨어진 정도

<br>

>**페이지 테이블 엔트리**

페이지 테이블의 각 행을 의미

<img>

- Vaild bit: 페이지에 접근 가능 여부를 나타냄 (메모리에 있으면 1, ❌ 0)
    - Page fault: 유효 비트가 0인 페이지에 접근하면 발생하는 예외
    - 처리 과정: CPU는 기존 작업 백업 > 페이지 폴트 처리 루틴 실행 > 메모리로 페이지 이동 후 유효 비트 1로 변경 ➡️ CPU로 페이지 접근
- Protection bit: 페이지를 보호하는 역할로 페이지의 읽고 쓰기 여부를 나타냄 (읽기만 가능 0, 읽고 쓰기 가능 1)
    - r(read), w(write), x(execute) 비트로 3가지 경우를 나타낼 수도 있음
- Reference bit: 페이지 접근 여부를 나타냄 (접근 있음 1, 접근 ❌ 0)
- Modified bit: 수정 여부를 나타냄 (수정 1, 수정 ❌ 0)
    - 수정이 됐으면 보조 기억 장치에 저장됐었던 값을 다시 기록하는 작업 필요

<br>

>**페이징의 장점 - 쓰기 시 복사**

<img>

- 읽는 작업만 반복된다면 부모와 자식 프로세스는 동일한 프레임을 사용하고 페이지 테이블만 따로 구성하면 됨
- 쓰기 작업이 진행되면 해당 페이지만 복사하여 사용함 ➡️ 생성 시간 및 메모리 공간 절약

<br>

>**계층적 페이징**

<img>

- 여러 단계의 페이지를 두는 기법으로 multilevel page table (다단계 페이지 테이블) 이라고도 함
- 바깥 페이지 번호 | 안쪽 페이지 번호 | 변위  형태

<br>

### 14-3 페이지 교체와 프레임 할당

>**요구 페이징**

페이지가 필요할 때에만 메모리에 적재하는 기법

1. CPU가 특정 페이지에 접근하는 명령어 실행
2. 유효 비트가 1일 경우 CPU는 페이지가 적재된 프레임에 접근함
3. 유효 비트가 0일 경우 페이지 폴트 발생
4. 페이지 폴트 처리 루틴은 페이지를 메모리로 적재 후 유효 비트를 1로 변경
5. 다시 1번 실행

- Pure demand paging (순수 요구 페이징): 메모리에 아무런 페이지도 적재하지 않은 채 무작정 실행하는 기법
- 페이지 교체: 메모리에 적재된 페이지를 보조기억장치로 보내는 과정
- 페이지 교체 알고리즘: 보조기억장치로 보낼 페이지를 결정하는 방법 

<br>

>**페이지 교체 알고리즘**

- 페이지 폴트를 가장 적게 일으키는 알고리즘이 좋은 알고리즘
- 페이지 폴트 횟수를 알아야 함 ➡️ page reference string을 통해 알 수 있음
- Page reference string (페이지 참조열): CPU가 참조하는 페이지들 중 연속된 페이지를 생략한 페이지열 

    ~~~
    2 2 2 3 5 5 5 3 3 7
    2 3 5 3 7 // 페이지 참조열
    ~~~

1. FIFO page replacement algorithm 
    <img>
    - 가장 먼저 올라온 페이지부터 내쫒는 방식
    - 구현이 쉽지만 성능이 좋지는 않음
    - Second chance page replacement algorithm: 참조 비트를 통해 한 번 더 기회를 주는 알고리즘
    - Belady’s Anomaly: 프레임의 개수가 많아져도 page fault가 줄어들지 않는 현상
        <img>
2. Optimal page replacement algorithm
    <img>
    - 가장 오랫동안 사용되지 않을 페이지를 내쫒는 방식
    - page fault가 가장 낮으며 Belady’s Anomaly 현상이 일어나지 않음
    - 구현이 어려움 ➡️ 다음 페이지를 예측하는 것은 현실적으로 불가능
    - 하한선으로 타 알고리즘의 평가를 위해 사용
3. LRU page replacement algorithm
    <img>
    - 가장 오랫동안 사용하지 않은 페이지를 내쫒는 방식
    - 최적 알고리즘과 비슷한 성능을 내며 많은 운영체제가 채택한 알고리즘

<br>

>**스래싱**

근본적으로 프레임의 개수가 작으면 페이지 폴트 빈도가 높음

- Thrashing: 프로세스를 실행하는 시간보다 페이징에 더 많은 시간을 소요하여 성능이 저해되는 문제
<img>
- Degree of multiprogramming: 메모리에서 동시에 실행되는 프로세스의 수
- 프로세스의 개수가 지나치게 ⬆️ ➡️ 이용 가능한 프레임 수 ⬇️ ➡️ 페이지 폴트 ⬆️ ➡️ CPU 이용률 ⬇️ 
- 프로세스가 필요한 최소한의 프레임 수 보장해서 할당 필요

<br>

>**프레임 할당 방식**

- 정적 할당 방식
    - Equal allocation (균등 할당): 모든 프로세스에 균등하게 프레임을 제공하는 방식
    - Proportional allocation (비례 할당): 프로세스 크기에 따라 프레임을 나눠주는 방식
- 동적 할당 방식: 실행 과정에서 할당
    - Working set model (작업 집합 모델): 실행 중인 프로세스가 일정 시간 동안 참조한 페이지 개수만큼 프레임을 할당하는 방식
    - PFF (페이지 폴트 빈도): 페이지 폴트율의 상/하한선을 정하고 그 범위 내에서만 프레임을 할당하는 방식